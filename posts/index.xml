<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 学习笔记</title><link>https://AxtengZwm.github.com/posts/</link><description>Recent content in Posts on 学习笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 08 Jun 2021 09:20:11 +0800</lastBuildDate><atom:link href="https://AxtengZwm.github.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>openmp</title><link>https://AxtengZwm.github.com/posts/openmp_1/</link><pubDate>Tue, 08 Jun 2021 09:20:11 +0800</pubDate><guid>https://AxtengZwm.github.com/posts/openmp_1/</guid><description>OpenMP API简述 openmp由三部分组成： 编译指令 运行时库程序 环境变量 编译指令: 目的：
产生平行区域 线程之间划分代码块 线程之间分配循环迭代 系列化代码段 线程之间的工作同步 格式：
1#parallel omp &amp;lt;directive&amp;gt; [clause[[,] clause] ...] 指令：（directive）
atomic 内存位置将会原子更新 barrier 线程在此等待，知道所有线程都运行到此指令。用来同步所有线程 critical 其后的代码块为临界区，任意时刻只能被一个线程运行 flush 所有线程对所有的共享对象具有相同的内存视图 for 将循环并行化由多个线程执行 master 指定主线程运行接下来的程序 ordered 接下来的代码块中，将被并行化的循环将依序进行 parallel 代表接下来的代码块被多个线程并行各执行一遍 sections 接下来的代码块包含被并行执行的section块 single 接下来的程序只会在单个线程中执行 threadprivate 指定一个变量为线性局部存储 从句：（clause）
copyin 让threadprivate的变量的值与主线程中的值相同 copyprivate 不同线程中的变量在所有线程中共享 default 指定并行域内的变量的使用方式，缺省是shared firstprivate 对于线程局部存储的变量，其初值是进行并行区之前的值 if 判断条件，用来决定是否要并行化 lastprivate 在一个循环并行执行结束后，指定变量的值为循环体在顺序最后一次执行时获取的值 nowait 忽略barrier的同步等待 num_threads 设置线程数量，默认值为计算机支持的最大并发数 ordered 适用于for，将程序中标记directive ordered 的部分依序运行 private 指定变量为线程局部存储 reduction 指定一个或多个变量是私有的，并在并行结束后执行指定的归约运算，并将结果返回至主线程同名变量 schedule 设置for循环的并行化方法；有dynamic，guided，runtime，static四种方法。shared指定变量为所有线程共享 schedule（static，chunk_szie）把chunk_size数目的循环的执行静态依序指定给各线程 schedule（dynamic，chunk_size)把循环体的执行按照chunk_size（缺省值为1）分为若干组，每个等待的线程获得当前一组去执行，执行完后重新等待分配新的组 schedule （guided，chunk_size）把循环体的执行分组分配给等待执行的线程，最初的组中的循环体执行数目较大，然后按指数方式下降到chunk_size schedule（runtime）循环并行化方式不在编译是静态确定，而是推迟到程序执行时动态地根据环境变量OMP_SCHEDULE来决定要使用的方法 库函数：</description></item><item><title>飞机结冰</title><link>https://AxtengZwm.github.com/posts/airplane-icing/</link><pubDate>Thu, 08 Oct 2020 09:20:11 +0800</pubDate><guid>https://AxtengZwm.github.com/posts/airplane-icing/</guid><description>绪论 飞机在低于冰点的温度下飞行时，如果穿越含有过冷水滴（温度低于冰点但仍保持液态的水）的云层，水滴碰在飞机表面上，就会在碰撞区域及其附近发生积冰。飞机积冰不但增加了部件重量，而且会改变绕流流场、破坏气动性能、导致部件载荷分布发生变化，使操纵性和稳定性受到影响，给飞行安全带来危害，轻者，会使安全飞行范围减小，重者，则会导致机毁人亡的严重事故。
积冰类型 按积冰的物理过程分类 霜冰：具有象砂纸一样粗糙而不透明的表面。组织比 较松脆，容易脱落且表面比较粗糙
明冰：外形不规则，沿表面流向的分布较广，冰中没有气泡，冰体透明并且组织致密，与表面的连接力大 混合冰：明冰与霜冰的混合体，表面粗糙不平且不易脱落 积霜：凝华而成，呈白色，晶体状外形，对气动外形改变不大，但会破坏绕机翼的光滑流动，导致上表面气流提前分离 干积冰：飞机在含有冰晶体的云层中飞行时，冰晶沉积在部件表面上所形成的积冰 实践表明，飞行中积霜和干积冰是极少发生的，大部分的积冰是由过冷水滴 冻结而导致的霜冰、明冰以及混合冰。因此，在研究飞机积冰问题时，一般是针 对这三种积冰类型进行讨论。
按冰的几何形状分类 粗糙度冰：粗糙度冰发生于积冰过程的初始阶段，冰的显著形状还没有形成。
角状冰：形成于明冰的积冰条件，外形通常包括上、下角主体部分，也包括角状冰下游的羽状区，角状冰对气动特性的影响比流向冰大，但比展向冰脊小。
流向冰：呈流线型，对气动特性的影响最小，在较冷的环境温度下，当水滴冻结在撞击表面时，最初的冰形状沿着物面外形产生，在较长的积冰时间、或当积冰条件恰当的时候，就可能形成流向冰。
展向冰脊：过冷水滴与物面撞击之后未冻结，而是沿着物面溢流，在撞击区之后形成突起的山脊状的冰，由于是溢流水冻结而形成，冰脊通常具有明冰的特质。
积冰强度 用水滴收集系数、飞行速度、液态水含量以及冻结比例等参数的组合来表征积冰强度的。</description></item><item><title>markdown 学习</title><link>https://AxtengZwm.github.com/posts/learning-markdown/</link><pubDate>Thu, 24 Sep 2020 09:20:11 +0800</pubDate><guid>https://AxtengZwm.github.com/posts/learning-markdown/</guid><description>测试</description></item><item><title>深度学习</title><link>https://AxtengZwm.github.com/posts/keras-study/</link><pubDate>Thu, 24 Sep 2020 09:20:11 +0800</pubDate><guid>https://AxtengZwm.github.com/posts/keras-study/</guid><description>机器学习笔记 以服装图形进行分类为例 课程来自https://tensorflow.google.cn/tutorials/keras/classification
1.导入相关包 1import tensorflow as tf 2from tensorflow import keras 3 4import numpy as np 5import matplotlib.pyplot as plt 2.导入数据集 1fashion_mnist = keras.datasets.fashion_mnist 2(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data() 3.数据预处理 此数据集中的图片像数值在0-255之间，将这些值缩小至0到1之间，再将其馈送到神经网络模型。
1train_images = train_images / 255.0 2test_images = test_iamges / 255.0 4.构建模型 设置层 1model = keras.Sequential([ 2keras.layers.Flatten(input_shape(28,28)),#将图像格式从二维数组（28*28）转换为一维数组784 3keras.layers.Dense(128, activation=&amp;#39;relu&amp;#39;),#Dense表示全连接层，128个节点，激活函数为relu 4keras.layers.Dense(10)#10个节点，代表本数据集中的十种分类 5 ]) 编译模型 1model.compile(optimizer = &amp;#39;adam&amp;#39;),#优化器 2loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits = True),#损失函数 3metrics = [&amp;#39;accuracy&amp;#39;]#指标，此处使用的是准确率，即分类正确比率 训练模型 1model.</description></item></channel></rss>