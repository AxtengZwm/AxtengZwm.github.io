<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.83.1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Axteng"><meta property="og:url" content="https://AxtengZwm.github.com/posts/openmp_1/"><link rel=canonical href=https://AxtengZwm.github.com/posts/openmp_1/><link rel=alternate type=application/atom+xml href=https://AxtengZwm.github.comindex.xml title=学习笔记><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/AxtengZwm.github.com"},"articleSection":"posts","name":"openmp","headline":"openmp","description":"OpenMP API简述 openmp由三部分组成：   编译指令 运行时库程序 环境变量   编译指令:  目的：\n 产生平行区域 线程之间划分代码块 线程之间分配循环迭代 系列化代码段 线程之间的工作同步   格式：\n1#parallel omp \u0026lt;directive\u0026gt; [clause[[,] clause] ...]  指令：（directive）\n atomic 内存位置将会原子更新 barrier 线程在此等待，知道所有线程都运行到此指令。用来同步所有线程 critical 其后的代码块为临界区，任意时刻只能被一个线程运行 flush 所有线程对所有的共享对象具有相同的内存视图 for 将循环并行化由多个线程执行 master 指定主线程运行接下来的程序 ordered 接下来的代码块中，将被并行化的循环将依序进行 parallel 代表接下来的代码块被多个线程并行各执行一遍 sections 接下来的代码块包含被并行执行的section块 single 接下来的程序只会在单个线程中执行 threadprivate 指定一个变量为线性局部存储   从句：（clause）\n copyin 让threadprivate的变量的值与主线程中的值相同 copyprivate 不同线程中的变量在所有线程中共享 default 指定并行域内的变量的使用方式，缺省是shared firstprivate 对于线程局部存储的变量，其初值是进行并行区之前的值 if 判断条件，用来决定是否要并行化 lastprivate 在一个循环并行执行结束后，指定变量的值为循环体在顺序最后一次执行时获取的值 nowait 忽略barrier的同步等待 num_threads 设置线程数量，默认值为计算机支持的最大并发数 ordered 适用于for，将程序中标记directive ordered 的部分依序运行 private 指定变量为线程局部存储 reduction 指定一个或多个变量是私有的，并在并行结束后执行指定的归约运算，并将结果返回至主线程同名变量 schedule 设置for循环的并行化方法；有dynamic，guided，runtime，static四种方法。shared指定变量为所有线程共享   schedule（static，chunk_szie）把chunk_size数目的循环的执行静态依序指定给各线程 schedule（dynamic，chunk_size)把循环体的执行按照chunk_size（缺省值为1）分为若干组，每个等待的线程获得当前一组去执行，执行完后重新等待分配新的组 schedule （guided，chunk_size）把循环体的执行分组分配给等待执行的线程，最初的组中的循环体执行数目较大，然后按指数方式下降到chunk_size schedule（runtime）循环并行化方式不在编译是静态确定，而是推迟到程序执行时动态地根据环境变量OMP_SCHEDULE来决定要使用的方法   库函数：","inLanguage":"en-US","author":"Axteng","creator":"Axteng","publisher":"Axteng","accountablePerson":"Axteng","copyrightHolder":"Axteng","copyrightYear":"2021","datePublished":"2021-06-08 09:20:11 \u002b0800 \u002b0800","dateModified":"2021-06-08 09:20:11 \u002b0800 \u002b0800","url":"https:\/\/AxtengZwm.github.com\/posts\/openmp_1\/","keywords":[]}</script><title>openmp - 学习笔记</title><meta property="og:title" content="openmp - 学习笔记"><meta property="og:type" content="article"><meta property="og:description" content="OpenMP API简述 openmp由三部分组成：   编译指令 运行时库程序 环境变量   编译指令:  目的：
 产生平行区域 线程之间划分代码块 线程之间分配循环迭代 系列化代码段 线程之间的工作同步   格式：
1#parallel omp <directive> [clause[[,] clause] ...]  指令：（directive）
 atomic 内存位置将会原子更新 barrier 线程在此等待，知道所有线程都运行到此指令。用来同步所有线程 critical 其后的代码块为临界区，任意时刻只能被一个线程运行 flush 所有线程对所有的共享对象具有相同的内存视图 for 将循环并行化由多个线程执行 master 指定主线程运行接下来的程序 ordered 接下来的代码块中，将被并行化的循环将依序进行 parallel 代表接下来的代码块被多个线程并行各执行一遍 sections 接下来的代码块包含被并行执行的section块 single 接下来的程序只会在单个线程中执行 threadprivate 指定一个变量为线性局部存储   从句：（clause）
 copyin 让threadprivate的变量的值与主线程中的值相同 copyprivate 不同线程中的变量在所有线程中共享 default 指定并行域内的变量的使用方式，缺省是shared firstprivate 对于线程局部存储的变量，其初值是进行并行区之前的值 if 判断条件，用来决定是否要并行化 lastprivate 在一个循环并行执行结束后，指定变量的值为循环体在顺序最后一次执行时获取的值 nowait 忽略barrier的同步等待 num_threads 设置线程数量，默认值为计算机支持的最大并发数 ordered 适用于for，将程序中标记directive ordered 的部分依序运行 private 指定变量为线程局部存储 reduction 指定一个或多个变量是私有的，并在并行结束后执行指定的归约运算，并将结果返回至主线程同名变量 schedule 设置for循环的并行化方法；有dynamic，guided，runtime，static四种方法。shared指定变量为所有线程共享   schedule（static，chunk_szie）把chunk_size数目的循环的执行静态依序指定给各线程 schedule（dynamic，chunk_size)把循环体的执行按照chunk_size（缺省值为1）分为若干组，每个等待的线程获得当前一组去执行，执行完后重新等待分配新的组 schedule （guided，chunk_size）把循环体的执行分组分配给等待执行的线程，最初的组中的循环体执行数目较大，然后按指数方式下降到chunk_size schedule（runtime）循环并行化方式不在编译是静态确定，而是推迟到程序执行时动态地根据环境变量OMP_SCHEDULE来决定要使用的方法   库函数："><meta name=description content="OpenMP API简述 openmp由三部分组成：   编译指令 运行时库程序 环境变量   编译指令:  目的：
 产生平行区域 线程之间划分代码块 线程之间分配循环迭代 系列化代码段 线程之间的工作同步   格式：
1#parallel omp <directive> [clause[[,] clause] ...]  指令：（directive）
 atomic 内存位置将会原子更新 barrier 线程在此等待，知道所有线程都运行到此指令。用来同步所有线程 critical 其后的代码块为临界区，任意时刻只能被一个线程运行 flush 所有线程对所有的共享对象具有相同的内存视图 for 将循环并行化由多个线程执行 master 指定主线程运行接下来的程序 ordered 接下来的代码块中，将被并行化的循环将依序进行 parallel 代表接下来的代码块被多个线程并行各执行一遍 sections 接下来的代码块包含被并行执行的section块 single 接下来的程序只会在单个线程中执行 threadprivate 指定一个变量为线性局部存储   从句：（clause）
 copyin 让threadprivate的变量的值与主线程中的值相同 copyprivate 不同线程中的变量在所有线程中共享 default 指定并行域内的变量的使用方式，缺省是shared firstprivate 对于线程局部存储的变量，其初值是进行并行区之前的值 if 判断条件，用来决定是否要并行化 lastprivate 在一个循环并行执行结束后，指定变量的值为循环体在顺序最后一次执行时获取的值 nowait 忽略barrier的同步等待 num_threads 设置线程数量，默认值为计算机支持的最大并发数 ordered 适用于for，将程序中标记directive ordered 的部分依序运行 private 指定变量为线程局部存储 reduction 指定一个或多个变量是私有的，并在并行结束后执行指定的归约运算，并将结果返回至主线程同名变量 schedule 设置for循环的并行化方法；有dynamic，guided，runtime，static四种方法。shared指定变量为所有线程共享   schedule（static，chunk_szie）把chunk_size数目的循环的执行静态依序指定给各线程 schedule（dynamic，chunk_size)把循环体的执行按照chunk_size（缺省值为1）分为若干组，每个等待的线程获得当前一组去执行，执行完后重新等待分配新的组 schedule （guided，chunk_size）把循环体的执行分组分配给等待执行的线程，最初的组中的循环体执行数目较大，然后按指数方式下降到chunk_size schedule（runtime）循环并行化方式不在编译是静态确定，而是推迟到程序执行时动态地根据环境变量OMP_SCHEDULE来决定要使用的方法   库函数："><meta property="og:locale" content="zh-cn"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title=学习笔记><link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class="post Chinese" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Axteng</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>openmp</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2021-06-08 09:20:11 +0800">2021.06.08</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://github.com/AxtengZwm/>@Axteng</a></div></div></div></header><div class="post-content markdown-body"><h1 id=openmp-api简述>OpenMP API简述</h1><h3 id=openmp由三部分组成>openmp由三部分组成：</h3><hr><ul><li>编译指令</li><li>运行时库程序</li><li>环境变量</li></ul><hr><h3 id=编译指令>编译指令:</h3><hr><p>目的：</p><ul><li>产生平行区域</li><li>线程之间划分代码块</li><li>线程之间分配循环迭代</li><li>系列化代码段</li><li>线程之间的工作同步</li></ul><hr><p>格式：</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback><span class=ln>1</span>#parallel omp &lt;directive&gt; [clause[[,] clause] ...]
</code></pre></div><hr><p>指令：（directive）</p><ul><li>atomic 内存位置将会原子更新</li><li>barrier 线程在此等待，知道所有线程都运行到此指令。用来同步所有线程</li><li>critical 其后的代码块为临界区，任意时刻只能被一个线程运行</li><li>flush 所有线程对所有的共享对象具有相同的内存视图</li><li>for 将循环并行化由多个线程执行</li><li>master 指定主线程运行接下来的程序</li><li>ordered 接下来的代码块中，将被并行化的循环将依序进行</li><li>parallel 代表接下来的代码块被多个线程并行<strong>各</strong>执行一遍</li><li>sections 接下来的代码块包含被并行执行的section块</li><li>single 接下来的程序只会在单个线程中执行</li><li>threadprivate 指定一个变量为线性局部存储</li></ul><hr><p>从句：（clause）</p><ul><li>copyin 让threadprivate的变量的值与主线程中的值相同</li><li>copyprivate 不同线程中的变量在所有线程中共享</li><li>default 指定并行域内的变量的使用方式，缺省是shared</li><li>firstprivate 对于线程局部存储的变量，其初值是进行并行区之前的值</li><li>if 判断条件，用来决定是否要并行化</li><li>lastprivate 在一个循环并行执行结束后，指定变量的值为循环体在顺序最后一次执行时获取的值</li><li>nowait 忽略barrier的同步等待</li><li>num_threads 设置线程数量，默认值为计算机支持的最大并发数</li><li>ordered 适用于for，将程序中标记directive ordered 的部分依序运行</li><li>private 指定变量为线程局部存储</li><li>reduction 指定一个或多个变量是私有的，并在并行结束后执行指定的归约运算，并将结果返回至主线程同名变量</li><li>schedule 设置for循环的并行化方法；有dynamic，guided，runtime，static四种方法。shared指定变量为所有线程共享</li></ul><ol><li>schedule（static，chunk_szie）把chunk_size数目的循环的执行静态依序指定给各线程</li><li>schedule（dynamic，chunk_size)把循环体的执行按照chunk_size（缺省值为1）分为若干组，每个等待的线程获得当前一组去执行，执行完后重新等待分配新的组</li><li>schedule （guided，chunk_size）把循环体的执行分组分配给等待执行的线程，最初的组中的循环体执行数目较大，然后按指数方式下降到chunk_size</li><li>schedule（runtime）循环并行化方式不在编译是静态确定，而是推迟到程序执行时动态地根据环境变量OMP_SCHEDULE来决定要使用的方法</li></ol><hr><p>库函数：</p><ul><li>void omp_set_num_threads(int nums)<br>在后续的并行区域设置线程数。只影响同级或内部嵌套级别的并行区域</li><li>int omp_get_num_threads()<br>返回当前线程数目</li><li>int omp_get_max_threads()<br>返回程序最大可用线程数目</li><li>int omp_get_thread_num()<br>返回当前线程id，主线程Id = 0</li><li>int omp_get_num_procs()<br>返回程序可用的处理器</li><li>int omp_set_dynamic(int_Dynamic_threads)<br>启用或禁用可用线程数的动态调整</li><li>int omp_get_dynamic()<br>确定在程序中是否启用了动态线程调整</li><li>int omp_in_parallel()<br>确定线程是否在并行区域的动态范围内执行</li><li>double omp_get_wtime()<br>获取时间</li></ul></div><div class="row middle-xs"><div class=col-xs-12><div class=post-category><a href=/categories/%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97>并行计算</a></div></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><div class=site-footer><div class=site-footer-item><a href=https://github.com/AxtengZwm/ target=_blank>Github</a></div><div class=site-footer-item><a href=mailto:AxtengZwm@google.com target=_blank>Mail</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script src=/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')})</script><script>hljs.initHighlightingOnLoad()</script></body></html>